{"priority": "minor", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/hoffmanlab/segway.json"}, "html": {"href": "#!/hoffmanlab/segway"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68bf38bf-f0c1-4c9c-909e-0ee4b2c26257}ts=python"}}, "type": "repository", "name": "segway", "full_name": "hoffmanlab/segway", "uuid": "{68bf38bf-f0c1-4c9c-909e-0ee4b2c26257}"}, "links": {"attachments": {"href": "data/repositories/hoffmanlab/segway/issues/78/attachments_page=1.json"}, "self": {"href": "data/repositories/hoffmanlab/segway/issues/78.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/issues/78/watch"}, "comments": {"href": "data/repositories/hoffmanlab/segway/issues/78/comments_page=1.json"}, "html": {"href": "#!/hoffmanlab/segway/issues/78/minibatch-sorts-windows-by-size-but-then"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/issues/78/vote"}}, "reporter": {"display_name": "Rachel Chan", "uuid": "{20430f8d-4e6b-48cc-a8d8-c64868bf7e79}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B20430f8d-4e6b-48cc-a8d8-c64868bf7e79%7D"}, "html": {"href": "https://bitbucket.org/%7B20430f8d-4e6b-48cc-a8d8-c64868bf7e79%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/4397abec9f84e35f1f235b350984833dd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsRC-1.png"}}, "nickname": "rcwchan", "type": "user", "account_id": "557058:e439e22e-8cfc-4cf1-b090-030d33a0730e"}, "title": "minibatch sorts windows by size, but then randomly selects from them", "component": null, "votes": 0, "watches": 1, "content": {"raw": "minibatch sorts windows by size, but then randomly selects from them (making this redundant).\r\n\r\n```\r\n#!python\r\n\r\n1834     def window_lens_sorted(self, reverse=True):\r\n1835         \"\"\"\r\n1836         yields (window_index, window_mem_usage)\r\n1837 \r\n1838         if reverse: sort windows by decreasing size, so the most\r\n1839         difficult windows are dropped in the queue first\r\n1840         \"\"\"\r\n1841         window_lens = self.window_lens\r\n1842 \r\n1843         # XXX: use key=itemgetter(2) and enumerate instead of this silliness\r\n1844         zipper = sorted(izip(window_lens, count()), reverse=reverse)\r\n1845 \r\n1846         # XXX: use itertools instead of a generator\r\n1847         for window_len, window_index in zipper:\r\n1848             yield window_index, window_len\r\n\r\n```\r\n\r\nand\r\n\r\n\r\n```\r\n#!python\r\n\r\n2080             train_windows_all = list(self.window_lens_sorted())\r\n...\r\n2122             train_window_indices_shuffled = choice(range(num_train_windows),\r\n2123                                                    num_train_windows,\r\n2124                                                    replace=False)\r\n```\r\n\r\nAnother question is, what was the original reasoning behind sorting the windows in the first place (in incr/decr size)?", "markup": "markdown", "html": "<p>minibatch sorts windows by size, but then randomly selects from them (making this redundant).</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"mi\">1834</span>     <span class=\"k\">def</span> <span class=\"nf\">window_lens_sorted</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">reverse</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">):</span>\n<span class=\"mi\">1835</span>         <span class=\"s2\">&quot;&quot;&quot;</span>\n<span class=\"s2\">1836         yields (window_index, window_mem_usage)</span>\n<span class=\"s2\">1837 </span>\n<span class=\"s2\">1838         if reverse: sort windows by decreasing size, so the most</span>\n<span class=\"s2\">1839         difficult windows are dropped in the queue first</span>\n<span class=\"s2\">1840         &quot;&quot;&quot;</span>\n<span class=\"mi\">1841</span>         <span class=\"n\">window_lens</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_lens</span>\n<span class=\"mi\">1842</span> \n<span class=\"mi\">1843</span>         <span class=\"c1\"># XXX: use key=itemgetter(2) and enumerate instead of this silliness</span>\n<span class=\"mi\">1844</span>         <span class=\"n\">zipper</span> <span class=\"o\">=</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">izip</span><span class=\"p\">(</span><span class=\"n\">window_lens</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">()),</span> <span class=\"n\">reverse</span><span class=\"o\">=</span><span class=\"n\">reverse</span><span class=\"p\">)</span>\n<span class=\"mi\">1845</span> \n<span class=\"mi\">1846</span>         <span class=\"c1\"># XXX: use itertools instead of a generator</span>\n<span class=\"mi\">1847</span>         <span class=\"k\">for</span> <span class=\"n\">window_len</span><span class=\"p\">,</span> <span class=\"n\">window_index</span> <span class=\"ow\">in</span> <span class=\"n\">zipper</span><span class=\"p\">:</span>\n<span class=\"mi\">1848</span>             <span class=\"k\">yield</span> <span class=\"n\">window_index</span><span class=\"p\">,</span> <span class=\"n\">window_len</span>\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite language-python\"><pre><span></span><span class=\"mi\">2080</span>             <span class=\"n\">train_windows_all</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_lens_sorted</span><span class=\"p\">())</span>\n<span class=\"o\">...</span>\n<span class=\"mi\">2122</span>             <span class=\"n\">train_window_indices_shuffled</span> <span class=\"o\">=</span> <span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_train_windows</span><span class=\"p\">),</span>\n<span class=\"mi\">2123</span>                                                    <span class=\"n\">num_train_windows</span><span class=\"p\">,</span>\n<span class=\"mi\">2124</span>                                                    <span class=\"n\">replace</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\n</pre></div>\n\n\n<p>Another question is, what was the original reasoning behind sorting the windows in the first place (in incr/decr size)?</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2016-08-02T15:30:52.357681+00:00", "milestone": null, "updated_on": "2016-08-02T15:31:36.316430+00:00", "type": "issue", "id": 78}