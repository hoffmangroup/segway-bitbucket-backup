{"rendered": {"description": {"raw": "This pull request removes any sleeping on the main thread when training with multiple instances. This stops any blocking on the main thread and allows all threads to immediately attempt to join the main thread. This also allows for `SIGINT` / `KeyboardInterrupt` to be immediately be caught if necessary from the main thread.\r\n\r\nThis PR also removes any sleeping from occuring with multiple instances when running locally.\r\n\r\nIn regards to Python 2 and the old implementation there were some discoveries about the existing code:\r\n\r\n* `KeyboardInterrupt`s were caught in the main thread but never caused the other threads to exit in any way. Single threaded works fine for `KeyboardInterrupt`s\r\n* The `JOIN_TIMEOUT` was effectively the window to poll for interrupts. Settings this shorter \\(to 1\\) would seem to have had the same effect with unknown performance penalty or gain.\r\n\r\nIt's worthwhile to note that currently, and as far as I can tell, when a `KeyboardInterrupt` or SIGINT is caught by the main thread \\(in Python 3 and now as implemented in Python 2\\), all threads stop due to an `IOError` exception since the main thread exits after the exception remains uncaught. There is no real \"graceful\" mechanism for other threads to terminate when a single thread dies nor can I find an implementation. There was a `interrupt_event` , of `Event` type, in the `Runner` object with no use anywhere \\(and was removed as dead code from this PR\\). It was `set` and nothing else checked it. Presumably it would be somehow passed on into a `RestartableJobDict` but there's no clear place where it would go since they are effectively queues with no obvious mechanism on how to exit gracefully themselves on a signal. It could be checked on the looping over training rounds but that might be too slow to wait for an entire EM iteration on a thread before exiting. Though that implementation might be desirable from a parameter iteration perspective and using segway-winner.", "markup": "markdown", "html": "<p>This pull request removes any sleeping on the main thread when training with multiple instances. This stops any blocking on the main thread and allows all threads to immediately attempt to join the main thread. This also allows for <code>SIGINT</code> / <code>KeyboardInterrupt</code> to be immediately be caught if necessary from the main thread.</p>\n<p>This PR also removes any sleeping from occuring with multiple instances when running locally.</p>\n<p>In regards to Python 2 and the old implementation there were some discoveries about the existing code:</p>\n<ul>\n<li><code>KeyboardInterrupt</code>s were caught in the main thread but never caused the other threads to exit in any way. Single threaded works fine for <code>KeyboardInterrupt</code>s</li>\n<li>The <code>JOIN_TIMEOUT</code> was effectively the window to poll for interrupts. Settings this shorter (to 1) would seem to have had the same effect with unknown performance penalty or gain.</li>\n</ul>\n<p>It's worthwhile to note that currently, and as far as I can tell, when a <code>KeyboardInterrupt</code> or SIGINT is caught by the main thread (in Python 3 and now as implemented in Python 2), all threads stop due to an <code>IOError</code> exception since the main thread exits after the exception remains uncaught. There is no real \"graceful\" mechanism for other threads to terminate when a single thread dies nor can I find an implementation. There was a <code>interrupt_event</code> , of <code>Event</code> type, in the <code>Runner</code> object with no use anywhere (and was removed as dead code from this PR). It was <code>set</code> and nothing else checked it. Presumably it would be somehow passed on into a <code>RestartableJobDict</code> but there's no clear place where it would go since they are effectively queues with no obvious mechanism on how to exit gracefully themselves on a signal. It could be checked on the looping over training rounds but that might be too slow to wait for an entire EM iteration on a thread before exiting. Though that implementation might be desirable from a parameter iteration perspective and using segway-winner.</p>", "type": "rendered"}, "title": {"raw": "Remove sleeping in main segway thread and any thread sleeping when running locally", "markup": "markdown", "html": "<p>Remove sleeping in main segway thread and any thread sleeping when running locally</p>", "type": "rendered"}}, "type": "pullrequest", "description": "This pull request removes any sleeping on the main thread when training with multiple instances. This stops any blocking on the main thread and allows all threads to immediately attempt to join the main thread. This also allows for `SIGINT` / `KeyboardInterrupt` to be immediately be caught if necessary from the main thread.\r\n\r\nThis PR also removes any sleeping from occuring with multiple instances when running locally.\r\n\r\nIn regards to Python 2 and the old implementation there were some discoveries about the existing code:\r\n\r\n* `KeyboardInterrupt`s were caught in the main thread but never caused the other threads to exit in any way. Single threaded works fine for `KeyboardInterrupt`s\r\n* The `JOIN_TIMEOUT` was effectively the window to poll for interrupts. Settings this shorter \\(to 1\\) would seem to have had the same effect with unknown performance penalty or gain.\r\n\r\nIt's worthwhile to note that currently, and as far as I can tell, when a `KeyboardInterrupt` or SIGINT is caught by the main thread \\(in Python 3 and now as implemented in Python 2\\), all threads stop due to an `IOError` exception since the main thread exits after the exception remains uncaught. There is no real \"graceful\" mechanism for other threads to terminate when a single thread dies nor can I find an implementation. There was a `interrupt_event` , of `Event` type, in the `Runner` object with no use anywhere \\(and was removed as dead code from this PR\\). It was `set` and nothing else checked it. Presumably it would be somehow passed on into a `RestartableJobDict` but there's no clear place where it would go since they are effectively queues with no obvious mechanism on how to exit gracefully themselves on a signal. It could be checked on the looping over training rounds but that might be too slow to wait for an entire EM iteration on a thread before exiting. Though that implementation might be desirable from a parameter iteration perspective and using segway-winner.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/pullrequests/103/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/diffstat/hoffmanlab/segway:492896b2d658%0Dda0cea64d98b?from_pullrequest_id=103"}, "commits": {"href": "data/repositories/hoffmanlab/segway/pullrequests/103/commits.json"}, "self": {"href": "data/repositories/hoffmanlab/segway/pullrequests/103.json"}, "comments": {"href": "data/repositories/hoffmanlab/segway/pullrequests/103/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/pullrequests/103/merge"}, "html": {"href": "#!/hoffmanlab/segway/pull-requests/103"}, "activity": {"href": "data/repositories/hoffmanlab/segway/pullrequests/103/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/diff/hoffmanlab/segway:492896b2d658%0Dda0cea64d98b?from_pullrequest_id=103"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/hoffmanlab/segway/pullrequests/103/approve"}, "statuses": {"href": "data/repositories/hoffmanlab/segway/pullrequests/103/statuses_page=1.json"}}, "title": "Remove sleeping in main segway thread and any thread sleeping when running locally", "close_source_branch": true, "reviewers": [{"display_name": "Michael Hoffman", "uuid": "{ffa8e039-5d4d-4f69-a4ba-ac25cbaf700b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bffa8e039-5d4d-4f69-a4ba-ac25cbaf700b%7D"}, "html": {"href": "https://bitbucket.org/%7Bffa8e039-5d4d-4f69-a4ba-ac25cbaf700b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/6a95e857a02504cbad5fe965c9d9e4bbd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMH-1.png"}}, "nickname": "hoffman", "type": "user", "account_id": "557058:a9657985-692c-405c-995b-4e41cda7ba2b"}], "id": 103, "destination": {"commit": {"hash": "da0cea64d98b", "type": "commit", "links": {"self": {"href": "data/repositories/hoffmanlab/segway/commit/da0cea64d98b.json"}, "html": {"href": "#!/hoffmanlab/segway/commits/da0cea64d98b"}}}, "repository": {"links": {"self": {"href": "data/repositories/hoffmanlab/segway.json"}, "html": {"href": "#!/hoffmanlab/segway"}, "avatar": {"href": "data/bytebucket.org/ravatar/{68bf38bf-f0c1-4c9c-909e-0ee4b2c26257}ts=python"}}, "type": "repository", "name": "segway", "full_name": "hoffmanlab/segway", "uuid": "{68bf38bf-f0c1-4c9c-909e-0ee4b2c26257}"}, "branch": {"name": "default"}}, "created_on": "2019-06-12T16:36:04.199755+00:00", "summary": {"raw": "This pull request removes any sleeping on the main thread when training with multiple instances. This stops any blocking on the main thread and allows all threads to immediately attempt to join the main thread. This also allows for `SIGINT` / `KeyboardInterrupt` to be immediately be caught if necessary from the main thread.\r\n\r\nThis PR also removes any sleeping from occuring with multiple instances when running locally.\r\n\r\nIn regards to Python 2 and the old implementation there were some discoveries about the existing code:\r\n\r\n* `KeyboardInterrupt`s were caught in the main thread but never caused the other threads to exit in any way. Single threaded works fine for `KeyboardInterrupt`s\r\n* The `JOIN_TIMEOUT` was effectively the window to poll for interrupts. Settings this shorter \\(to 1\\) would seem to have had the same effect with unknown performance penalty or gain.\r\n\r\nIt's worthwhile to note that currently, and as far as I can tell, when a `KeyboardInterrupt` or SIGINT is caught by the main thread \\(in Python 3 and now as implemented in Python 2\\), all threads stop due to an `IOError` exception since the main thread exits after the exception remains uncaught. There is no real \"graceful\" mechanism for other threads to terminate when a single thread dies nor can I find an implementation. There was a `interrupt_event` , of `Event` type, in the `Runner` object with no use anywhere \\(and was removed as dead code from this PR\\). It was `set` and nothing else checked it. Presumably it would be somehow passed on into a `RestartableJobDict` but there's no clear place where it would go since they are effectively queues with no obvious mechanism on how to exit gracefully themselves on a signal. It could be checked on the looping over training rounds but that might be too slow to wait for an entire EM iteration on a thread before exiting. Though that implementation might be desirable from a parameter iteration perspective and using segway-winner.", "markup": "markdown", "html": "<p>This pull request removes any sleeping on the main thread when training with multiple instances. This stops any blocking on the main thread and allows all threads to immediately attempt to join the main thread. This also allows for <code>SIGINT</code> / <code>KeyboardInterrupt</code> to be immediately be caught if necessary from the main thread.</p>\n<p>This PR also removes any sleeping from occuring with multiple instances when running locally.</p>\n<p>In regards to Python 2 and the old implementation there were some discoveries about the existing code:</p>\n<ul>\n<li><code>KeyboardInterrupt</code>s were caught in the main thread but never caused the other threads to exit in any way. Single threaded works fine for <code>KeyboardInterrupt</code>s</li>\n<li>The <code>JOIN_TIMEOUT</code> was effectively the window to poll for interrupts. Settings this shorter (to 1) would seem to have had the same effect with unknown performance penalty or gain.</li>\n</ul>\n<p>It's worthwhile to note that currently, and as far as I can tell, when a <code>KeyboardInterrupt</code> or SIGINT is caught by the main thread (in Python 3 and now as implemented in Python 2), all threads stop due to an <code>IOError</code> exception since the main thread exits after the exception remains uncaught. There is no real \"graceful\" mechanism for other threads to terminate when a single thread dies nor can I find an implementation. There was a <code>interrupt_event</code> , of <code>Event</code> type, in the <code>Runner</code> object with no use anywhere (and was removed as dead code from this PR). It was <code>set</code> and nothing else checked it. Presumably it would be somehow passed on into a <code>RestartableJobDict</code> but there's no clear place where it would go since they are effectively queues with no obvious mechanism on how to exit gracefully themselves on a signal. It could be checked on the looping over training rounds but that might be too slow to wait for an entire EM iteration on a thread before exiting. Though that implementation might be desirable from a parameter iteration perspective and using segway-winner.</p>", "type": "rendered"}, "source": {"commit": {"hash": "23c97c52b364", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/ericr86/segway/commit/23c97c52b364"}, "html": {"href": "https://bitbucket.org/ericr86/segway/commits/23c97c52b364"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/ericr86/segway"}, "html": {"href": "https://bitbucket.org/ericr86/segway"}, "avatar": {"href": "data/bytebucket.org/ravatar/{e4afec35-c393-4c1b-9d35-155fcd95ef33}ts=python"}}, "type": "repository", "name": "segway", "full_name": "ericr86/segway", "uuid": "{e4afec35-c393-4c1b-9d35-155fcd95ef33}"}, "branch": {"name": "no-local-thread-sleep"}}, "comment_count": 0, "state": "MERGED", "task_count": 0, "participants": [{"role": "REVIEWER", "participated_on": "2019-06-12T20:26:43.641373+00:00", "type": "participant", "approved": true, "user": {"display_name": "Michael Hoffman", "uuid": "{ffa8e039-5d4d-4f69-a4ba-ac25cbaf700b}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bffa8e039-5d4d-4f69-a4ba-ac25cbaf700b%7D"}, "html": {"href": "https://bitbucket.org/%7Bffa8e039-5d4d-4f69-a4ba-ac25cbaf700b%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/6a95e857a02504cbad5fe965c9d9e4bbd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMH-1.png"}}, "nickname": "hoffman", "type": "user", "account_id": "557058:a9657985-692c-405c-995b-4e41cda7ba2b"}}], "reason": "", "updated_on": "2019-06-13T13:21:53.251029+00:00", "author": {"display_name": "Eric Roberts", "uuid": "{cd8c1fe0-28ca-45fb-8ef9-48090b42bb80}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bcd8c1fe0-28ca-45fb-8ef9-48090b42bb80%7D"}, "html": {"href": "https://bitbucket.org/%7Bcd8c1fe0-28ca-45fb-8ef9-48090b42bb80%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/17548d71dfb29d015b880f48cfc01ca3d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsER-5.png"}}, "nickname": "ericr86", "type": "user", "account_id": "557058:c80ca578-03a1-4ac6-b3ee-50372a3fceee"}, "merge_commit": {"hash": "492896b2d658", "type": "commit", "links": {"self": {"href": "data/repositories/hoffmanlab/segway/commit/492896b2d658.json"}, "html": {"href": "#!/hoffmanlab/segway/commits/492896b2d658"}}}, "closed_by": {"display_name": "Eric Roberts", "uuid": "{cd8c1fe0-28ca-45fb-8ef9-48090b42bb80}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bcd8c1fe0-28ca-45fb-8ef9-48090b42bb80%7D"}, "html": {"href": "https://bitbucket.org/%7Bcd8c1fe0-28ca-45fb-8ef9-48090b42bb80%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/17548d71dfb29d015b880f48cfc01ca3d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsER-5.png"}}, "nickname": "ericr86", "type": "user", "account_id": "557058:c80ca578-03a1-4ac6-b3ee-50372a3fceee"}}